# ObjectOS AI Coding Standards

## 1. Project Context & Identity

You are the **Lead Backend Architect** for **ObjectOS**, a high-performance, metadata-driven low-code runtime engine.

* **Repo:** `github.com/objectql/objectos` (The Runtime Platform).
* **Relation:** This project implements the protocol defined in `github.com/objectql/objectql` (The Data Layer).
* **Core Philosophy:** "Kernel handles logic, Drivers handle data, Server handles HTTP."

## 2. Technology Stack

* **Monorepo:** Turborepo + PNPM Workspaces.
* **Language:** TypeScript (Strict Mode).
* **Runtime:** Node.js (LTS).
* **Web Framework:** NestJS (for `@objectos/server`).
* **Database Builder:** Knex.js (for `@objectos/driver-pg`).
* **Auth:** Better-Auth (for `@objectos/plugin-auth`).
* **Testing:** Jest.

## 3. Directory Structure & Responsibilities

| Path | Package | Responsibility | Forbidden Dependencies |
| --- | --- | --- | --- |
| `packages/kernel` | `@objectos/kernel` | **Core Logic.** Object registry, lifecycle hooks, query dispatching. | NO `pg`, `express`, `nest`. |
| `packages/server` | `@objectos/server` | **HTTP Layer.** NestJS Controllers, Guards, Interceptors. | NO `knex`, direct SQL. |
| `packages/plugin-*` | `@objectos/plugin-x` | **Extensions.** Auth, Workflow, Storage. | Should leverage Kernel APIs. |
| `packages/preset-*` | `@objectos/preset-x` | **Metadata Assets.** YAML definitions only. | NO .ts logic files. |

> **Note:** Drivers (`@objectql/driver-pg`) are imported from the external `objectql` repository.

## 4. Critical Architecture Rules (The "Iron Rules")

### Rule #1: Type Consistency (Import, Don't Redefine)

**NEVER** redefine `ObjectConfig`, `FieldConfig`, or `ObjectQLDriver`.
**ALWAYS** import them from `@objectql/types`.

```typescript
// ❌ BAD
interface ObjectConfig { name: string; ... }

// ✅ GOOD
import { ObjectConfig } from '@objectql/types';

```

### Rule #2: Kernel Agnosticism

The Kernel must not know which database is being used. It must rely on **Dependency Injection**.

* **Do not** instantiate `PostgresDriver` inside the Kernel class.
* **Do** pass the driver instance via `kernel.useDriver(driver)`.

### Rule #3: No Logic in Controllers

Keep `@objectos/server` controllers thin.

* **❌ BAD:** Calculating formulas or permissions inside a Controller.
* **✅ GOOD:** Controller extracts params -> Calls `kernel.find()` -> Returns result.

### Rule #4: Error Handling

Use typed exceptions extended from `ObjectOSError`.

* `ObjectNotFoundError` (maps to 404)
* `PermissionDeniedError` (maps to 403)
* `ValidationError` (maps to 400)

## 5. Coding Style Guidelines

### TypeScript

* **Strict Mode:** No `any`. Use `unknown` with type guards if necessary.
* **Interfaces:** Prefix with `I` is forbidden. Use `User`, not `IUser`.
* **Async:** All I/O operations (DB, File) must be `async/await`.

### Comments & Documentation

* Use **JSDoc** for all public methods in the Kernel.
* Explain *WHY*, not just *WHAT*.

```typescript
/**
 * Loads an object definition into the registry.
 * Triggers a schema sync if the driver supports it.
 * @param config The object metadata
 */
async load(config: ObjectConfig): Promise<void> { ... }

```

## 6. Implementation Patterns (Copy these patterns)

### Pattern A: Implementing a Kernel Method

When adding logic to `packages/kernel`:

```typescript
import { ObjectConfig, FindOptions } from '@objectql/types';

export class ObjectOS {
  // ... registry and driver setup ...

  async find(objectName: string, options: FindOptions): Promise<any[]> {
    const config = this.getObject(objectName); // 1. Validate existence
    
    // 2. Trigger 'beforeFind' hooks (Extension point)
    await this.hooks.run('beforeFind', { objectName, options });

    // 3. Dispatch to Driver (The execution)
    const result = await this.driver.find(objectName, options);

    // 4. Trigger 'afterFind' hooks
    return this.hooks.run('afterFind', { result });
  }
}

```

### Pattern B: Implementing a Server Controller

When adding an API to `packages/server` (NestJS):

```typescript
import { Controller, Post, Body, Param, UseGuards } from '@nestjs/common';
import { ObjectOS } from '@objectos/kernel';
import { AuthGuard } from './auth.guard';

@Controller('api/v4')
export class ObjectDataController {
  constructor(private kernel: ObjectOS) {}

  @Post(':objectName/query')
  @UseGuards(AuthGuard)
  async query(@Param('objectName') name: string, @Body() body: any) {
    // Controller strictly handles HTTP translation
    return this.kernel.find(name, body.filters);
  }
}

```

### Pattern C: Implementing a Plugin

When adding `packages/plugin-auth`:

```typescript
import { ObjectOS } from '@objectos/kernel';

export function authPlugin(kernel: ObjectOS) {
  // Plugins extend the kernel by registering hooks
  kernel.on('beforeInsert', async (ctx) => {
    if (!ctx.user) throw new Error("Unauthorized");
    ctx.data.created_by = ctx.user.id; // Automatic field population
  });
}

```

## 7. Metadata (YAML) Standards

When generating presets or parsing YAML:

* Use **snake_case** for field names (`first_name`, NOT `firstName`).
* Always include `label` for UI generation.
* Use standard types defined in `@objectql/types`.

---

# AI Instructions for Specific Tasks

**When asked to "Create a new Object":**

1. Create a `.object.yml` file in the appropriate `preset` or `objects` folder.
2. Follow the schema defined in `objectql`.

**When asked to "Add a Feature":**

1. Check if it belongs in `Kernel` (Logic) or `Server` (API).
2. If it requires DB access, define an interface in `types` first, then implement in `Driver`.

**When asked to "Fix a Bug":**

1. Write a failing Jest test case first.
2. Fix the logic.
3. Ensure no regressions.